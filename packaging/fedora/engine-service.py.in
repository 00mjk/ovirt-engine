#!/usr/bin/python

# Copyright 2012 Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import glob
import grp
import os
import pwd
import re
import shutil
import signal
import stat
import sys
import syslog
import time
import subprocess
from optparse import OptionParser

import daemon
from Cheetah.Template import Template


# The name of the engine:
engineName = "engine-service"

# Misc
foreground = False

# The engine system configuration variables:
engineDefaultsFile = None
engineConfigFile = None
engineConfig = None

# The name of the user and group that should run the service:
engineUid = None
engineGid = None

# Java home directory:
javaHomeDir = None

# Java virtual machine launcher:
javaLauncher = None

# JBoss directories:
jbossHomeDir = None

# JBoss files:
jbossModulesJar = None
jbossBootLoggingTemplateFile = None
jbossBootLoggingFile = None

# Engine directories:
engineEtcDir = None
engineLogDir = None
engineTmpDir = None
engineUsrDir = None
engineVarDir = None
engineCacheDir = None
engineContentDir = None
engineDeploymentsDir = None
engineServiceDir = None

# Engine files:
enginePidFile = None
engineLogFile = None
jbossConfigFile = None
engineConsoleLogFile = None
engineServerLogFile = None
jbossConfigTemplateFile = None


# Helper class to simplify getting values from the configuration, specially
# from the template used to generate the application server configuration
# file:
class Config():
    # Compile regular expressions:
    COMMENT_EXPR = re.compile(r"\s*#.*$")
    BLANK_EXPR = re.compile(r"^\s*$")
    VALUE_EXPR = re.compile(r"^\s*(\w+)\s*=\s*(.*?)\s*$")
    REF_EXPR = re.compile(r"\$\{(\w+)\}")

    def __init__(self, files):
        # Save the list of files:
        self.files = files

        # Start with an empty set of values:
        self.values = {}

        # Merge all the given configuration files, in the same order
        # given, so that the values in one file are overriden by values
        # in files appearing later in the list:
        for file in self.files:
            self.loadFile(file)

    def loadFile(self, file):
        with open(file, "r") as fd:
            for line in fd:
                self.loadLine(line)

    def loadLine(self, line):
        # Remove comments:
        commentMatch = Config.COMMENT_EXPR.search(line)
        if commentMatch is not None:
            line = line[:commentMatch.start()] + line[commentMatch.end():]

        # Skip empty lines:
        emptyMatch = Config.BLANK_EXPR.search(line)
        if emptyMatch is not None:
            return

        # Separate name from value:
        keyValueMatch = Config.VALUE_EXPR.search(line)
        if keyValueMatch is None:
            return
        key = keyValueMatch.group(1)
        value = keyValueMatch.group(2)

        # Strip quotes from value:
        if len(value) >= 2 and value[0] == '"' and value[-1] == '"':
            value = value[1:-1]

        # Expand references to other parameters:
        while True:
            refMatch = Config.REF_EXPR.search(value)
            if refMatch is None:
                break
            refKey = refMatch.group(1)
            refValue = self.values.get(refKey)
            if refValue is None:
                break
            value = value[:refMatch.start()] + refValue + value[refMatch.end():]

        # Update the values:
        self.values[key] = value

    def getString(self, name):
        text = self.values.get(name)
        if text is None:
            raise Exception("The parameter \"%s\" doesn't have a value." % name)
        return text

    def getBoolean(self, name):
        text = self.getString(name)
        return text.lower() in ["t", "true", "y", "yes", "1"]

    def getInteger(self, name):
        text = self.getString(name)
        try:
            return int(text)
        except:
            raise Exception("The value \"%s\" of parameter \"%s\" is not a valid integer." % (text, name))


def loadConfig():
    # Locate the defaults file:
    global engineDefaultsFile
    engineDefaultsFile = os.getenv("ENGINE_DEFAULTS", "@ENGINE_DEFAULTS@")
    if not os.path.exists(engineDefaultsFile):
        raise Exception("The engine configuration defaults file \"%s\" doesn't exist." % engineDefaultsFile)

    # Locate the configuration file:
    global engineConfigFile
    engineConfigFile = os.getenv("ENGINE_VARS", "@ENGINE_VARS@")
    if not os.path.exists(engineConfigFile):
        raise Exception("The engine configuration file \"%s\" doesn't exist." % engineConfigFile)

    # This will be the list of configuration files to load and merge, later
    # files override earlier ones:
    engineConfigFiles = [
        engineDefaultsFile,
        engineConfigFile,
    ]

    # Find additional configuration files in the optional configuration
    # directory, sorted alphabetically so that numeric prefixes can be used to
    # force the order:
    engineConfigDir = engineConfigFile + ".d"
    if os.path.isdir(engineConfigDir):
        additionalEngineConfigFiles = glob.glob(engineConfigDir + "/*.conf")
        additionalEngineConfigFiles.sort()
        engineConfigFiles.extend(additionalEngineConfigFiles)

    # Merge all the configuration files:
    global engineConfig
    engineConfig = Config(engineConfigFiles)

    # Get the id of the engine user:
    global engineUid
    if os.geteuid() == 0:
        engineUser = engineConfig.getString("ENGINE_USER")
        if engineUser:
            try:
                engineUid = pwd.getpwnam(engineUser).pw_uid
            except:
                raise Exception("The engine user \"%s\" doesn't exist." % engineUser)
    else:
        engineUid = os.geteuid()

    # Get id of the engine group:
    global engineGid
    if os.geteuid() == 0:
        engineGroup = engineConfig.getString("ENGINE_GROUP")
        if engineGroup:
            try:
                engineGid = grp.getgrnam(engineGroup).gr_gid
            except:
                raise Exception("The engine group \"%s\" doesn't exist." % engineGroup)
    else:
        engineGid = os.getegid()

    # Java home directory:
    global javaHomeDir
    javaHomeDir = engineConfig.getString("JAVA_HOME")

    # Java launcher:
    global javaLauncher
    javaLauncher = os.path.join(javaHomeDir, "bin/java")

    # Engine directories:
    global engineEtcDir
    global engineLogDir
    global engineTmpDir
    global engineUsrDir
    global engineVarDir
    global engineCacheDir
    global engineServiceDir
    global engineContentDir
    global engineDeploymentsDir
    engineEtcDir = engineConfig.getString("ENGINE_ETC")
    engineLogDir = engineConfig.getString("ENGINE_LOG")
    engineTmpDir = engineConfig.getString("ENGINE_TMP")
    engineUsrDir = engineConfig.getString("ENGINE_USR")
    engineVarDir = engineConfig.getString("ENGINE_VAR")
    engineCacheDir = engineConfig.getString("ENGINE_CACHE")
    engineServiceDir = os.path.join(engineUsrDir, "service")
    engineContentDir = os.path.join(engineVarDir, "content")
    engineDeploymentsDir = os.path.join(engineVarDir, "deployments")

    # Engine files:
    global engineLogFile
    global engineConsoleLogFile
    global engineServerLogFile
    engineLogFile = os.path.join(engineLogDir, "engine.log")
    engineConsoleLogFile = os.path.join(engineLogDir, "console.log")
    engineServerLogFile = os.path.join(engineLogDir, "server.log")

    # JBoss directories:
    global jbossHomeDir
    jbossHomeDir = engineConfig.getString("JBOSS_HOME")

    # JBoss files:
    global jbossModulesJar
    global jbossBootLoggingTemplateFile
    global jbossBootLoggingFile
    global jbossConfigTemplateFile
    global jbossConfigFile
    jbossModulesJar = os.path.join(jbossHomeDir, "jboss-modules.jar")
    jbossBootLoggingTemplateFile = os.path.join(engineServiceDir, "engine-service-logging.properties.in")
    jbossBootLoggingFile = os.path.join(engineTmpDir, "engine-service-logging.properties")
    jbossConfigTemplateFile = os.path.join(engineServiceDir, "engine-service.xml.in")
    jbossConfigFile = os.path.join(engineTmpDir, "engine-service.xml")


def checkOwnership(name, uid=None, gid=None):
    # Get the metadata of the file:
    st = os.stat(name)

    # Check that the file is owned by the given user:
    if uid and st[stat.ST_UID] != uid:
        user = pwd.getpwuid(uid).pw_name
        owner = pwd.getpwuid(st[stat.ST_UID]).pw_name
        if os.path.isdir(name):
            raise Exception("The directory \"%s\" is not owned by user \"%s\", but by \"%s\"." % (name, user, owner))
        else:
            raise Exception("The file \"%s\" is not owned by user \"%s\", but by \"%s\"." % (name, user, owner))

    # Check that the file is owned by the given group:
    if gid and st[stat.ST_GID] != gid:
        group = grp.getgrgid(gid).gr_name
        owner = grp.getgrgid(st[stat.ST_GID]).gr_name
        if os.path.isdir(name):
            raise Exception("The directory \"%s\" is not owned by group \"%s\", but by \"%s\"." % (name, group, owner))
        else:
            raise Exception("The file \"%s\" is not owned by group \"%s\", but by \"%s\"." % (name, group, owner))


def checkDirectory(name, uid=None, gid=None):
    if not os.path.isdir(name):
        raise Exception("The directory \"%s\" doesn't exist." % name)
    checkOwnership(name, uid, gid)


def checkFile(name, uid=None, gid=None):
    if not os.path.isfile(name):
        raise Exception("The file \"%s\" doesn't exist." % name)
    checkOwnership(name, uid, gid)


def checkLog(name):
    log = os.path.join(engineLogDir, name)
    if os.path.exists(log):
        checkOwnership(log, engineUid, engineGid)


def checkInstallation():
    # Check that the Java home directory exists and that it contais at least
    # the java executable:
    checkDirectory(javaHomeDir)
    checkFile(javaLauncher)

    # Check the required JBoss directories and files:
    checkDirectory(jbossHomeDir)
    checkFile(jbossModulesJar)

    # Check the required engine directories and files:
    checkDirectory(engineLogDir, uid=engineUid, gid=engineGid)
    checkDirectory(engineUsrDir)
    checkDirectory(engineVarDir, uid=engineUid, gid=engineGid)
    checkDirectory(engineServiceDir)
    checkDirectory(engineContentDir, uid=engineUid, gid=engineGid)
    checkDirectory(engineDeploymentsDir, uid=engineUid, gid=engineGid)
    checkFile(jbossBootLoggingTemplateFile)
    checkFile(jbossConfigTemplateFile)

    # Check that log files are owned by the engine user, if they exist:
    checkLog(engineLogFile)
    checkLog(engineConsoleLogFile)
    checkLog(engineServerLogFile)

    # XXX: Add more checks here!


def saveEnginePid(pid):
    if enginePidFile is not None:
        with open(enginePidFile, "w") as enginePidFd:
            enginePidFd.write(str(pid) + "\n")


def removeEnginePid():
    if enginePidFile is not None and os.path.exists(enginePidFile):
        try:
            os.remove(enginePidFile)
        except OSError:
            # we may not have permissions to delete pid
            # so just try to empty it
            try:
                with open(enginePidFile, 'w'):
                    pass
            except IOError:
                pass


def startEngine():
    # perform checks:
    checkInstallation()

    # The list of applications to be deployed:
    engineApps = engineConfig.getString("ENGINE_APPS").split()

    for engineApp in engineApps:
        # Do nothing if the application is not available:
        engineAppDir = os.path.join(engineUsrDir, engineApp)
        if not os.path.exists(engineAppDir):
            syslog.syslog(syslog.LOG_WARNING, "The application \"%s\" doesn't exist, it will be ignored." % engineAppDir)
            continue

        # Make sure the application is linked in the deployments directory, if not
        # link it now:
        engineAppLink = os.path.join(engineDeploymentsDir, engineApp)
        if not os.path.islink(engineAppLink):
            syslog.syslog(syslog.LOG_INFO, "The symbolic link \"%s\" doesn't exist, will create it now." % engineAppLink)
            try:
                os.symlink(engineAppDir, engineAppLink)
            except:
                raise Exception("Can't create symbolic link from \"%s\" to \"%s\"." % (engineAppLink, engineAppDir))

        # Remove all existing deployment markers:
        for markerFile in glob.glob("%s.*" % engineAppLink):
            try:
                os.remove(markerFile)
            except:
                raise Exception("Can't remove deployment marker file \"%s\"." % markerFile)

        # Create the new marker file to trigger deployment of the application:
        markerFile = "%s.dodeploy" % engineAppLink
        try:
            markerFd = open(markerFile, "w")
            markerFd.close()
        except:
            raise Exception("Can't create deployment marker file \"%s\"." % markerFile)

    # Clean and recreate the temporary directory:
    if os.path.exists(engineTmpDir):
        shutil.rmtree(engineTmpDir)
    os.mkdir(engineTmpDir)

    # Create cache directory if does not exist
    os.chown(engineTmpDir, engineUid, engineGid)
    if not os.path.exists(engineCacheDir):
        os.mkdir(engineCacheDir)
    os.chown(engineCacheDir, engineUid, engineGid)

    # Create the boot logging file from the template:
    jbossBootLoggingTemplate = Template(file=jbossBootLoggingTemplateFile, searchList=[engineConfig])
    jbossBootLoggingText = str(jbossBootLoggingTemplate)
    with open(jbossBootLoggingFile, "w") as jbossBootLoggingFd:
        jbossBootLoggingFd.write(jbossBootLoggingText)
    os.chown(jbossBootLoggingFile, engineUid, engineGid)

    # Generate the main configuration from the template and copy it to the
    # configuration temporary directory making sure that the application server
    # will be able to write to it:
    jbossConfigTemplate = Template(file=jbossConfigTemplateFile, searchList=[engineConfig])
    jbossConfigText = str(jbossConfigTemplate)
    with open(jbossConfigFile, "w") as jbossConfigFd:
        jbossConfigFd.write(jbossConfigText)
    os.chown(jbossConfigFile, engineUid, engineGid)

    # Get heap configuration parameters from the environment or use defaults if
    # they are not provided:
    engineHeapMin = engineConfig.getString("ENGINE_HEAP_MIN")
    engineHeapMax = engineConfig.getString("ENGINE_HEAP_MAX")
    enginePermMin = engineConfig.getString("ENGINE_PERM_MIN")
    enginePermMax = engineConfig.getString("ENGINE_PERM_MAX")

    # Modules directories:
    jbossModulesDir = os.path.join(jbossHomeDir, "modules")
    engineModulesDir = os.path.join(engineUsrDir, "modules")

    # Link all the JBoss modules into a temporary directory:
    jbossModulesTmpDir = os.path.join(engineTmpDir, "modules")
    linkModules(jbossModulesDir, jbossModulesTmpDir)

    # Module path should include first the engine modules so that they can override
    # those provided by the application server if needed:
    engineModulePath = "%s:%s" % (engineModulesDir, jbossModulesTmpDir)

    # We start with an empty list of arguments:
    engineArgs = []

    # Add arguments for the java virtual machine:
    engineArgs.extend([
        # The name or the process, as displayed by ps:
        engineName,

        # Virtual machine options:
        "-server",
        "-XX:+TieredCompilation",
        "-Xms%s" % engineHeapMin,
        "-Xmx%s" % engineHeapMax,
        "-XX:PermSize=%s" % enginePermMin,
        "-XX:MaxPermSize=%s" % enginePermMax,
        "-Djava.net.preferIPv4Stack=true",
        "-Dsun.rmi.dgc.client.gcInterval=3600000",
        "-Dsun.rmi.dgc.server.gcInterval=3600000",
        "-Djava.awt.headless=true",
    ])

    # Add extra system properties provided in the configuration:
    engineProperties = engineConfig.getString("ENGINE_PROPERTIES")
    if engineProperties:
        for engineProperty in engineProperties.split():
            if not engineProperty.startswith("-D"):
                engineProperty = "-D" + engineProperty
            engineArgs.append(engineProperty)

    # Add arguments for remote debugging of the java virtual machine:
    engineDebugAddress = engineConfig.getString("ENGINE_DEBUG_ADDRESS")
    if engineDebugAddress:
        engineArgs.append("-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n" % engineDebugAddress)

    # Enable verbose garbage collection if required:
    engineVerboseGC = engineConfig.getBoolean("ENGINE_VERBOSE_GC")
    if engineVerboseGC:
        engineArgs.extend([
            "-verbose:gc",
            "-XX:+PrintGCTimeStamps",
            "-XX:+PrintGCDetails",
        ])

    # Add arguments for JBoss:
    engineArgs.extend([
        "-Djava.util.logging.manager=org.jboss.logmanager",
        "-Dlogging.configuration=file://%s" % jbossBootLoggingFile,
        "-Dorg.jboss.resolver.warning=true",
        "-Djboss.modules.system.pkgs=org.jboss.byteman",
        "-Djboss.modules.write-indexes=false",
        "-Djboss.server.default.config=engine-service",
        "-Djboss.home.dir=%s" % jbossHomeDir,
        "-Djboss.server.base.dir=%s" % engineUsrDir,
        "-Djboss.server.config.dir=%s" % engineTmpDir,
        "-Djboss.server.data.dir=%s" % engineVarDir,
        "-Djboss.server.log.dir=%s" % engineLogDir,
        "-Djboss.server.temp.dir=%s" % engineTmpDir,
        "-Djboss.controller.temp.dir=%s" % engineTmpDir,
        "-jar", jbossModulesJar,
        "-mp", engineModulePath,
        "-jaxpmodule", "javax.xml.jaxp-provider",
        "org.jboss.as.standalone", "-c", os.path.basename(jbossConfigFile),
    ])

    # Prepare a clean environment:
    engineEnv = {
        "PATH": "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin",
        "LANG": "en_US.UTF-8",
        "ENGINE_DEFAULTS": engineDefaultsFile,
        "ENGINE_VARS": engineConfigFile,
        "ENGINE_ETC": engineEtcDir,
        "ENGINE_LOG": engineLogDir,
        "ENGINE_TMP": engineTmpDir,
        "ENGINE_USR": engineUsrDir,
        "ENGINE_VAR": engineVarDir,
        "ENGINE_CACHE": engineCacheDir,
    }

    # this is required to allow
    # writing after user id is changed
    if enginePidFile is not None:
        with open(enginePidFile, 'w'):
            pass
        os.chown(enginePidFile, engineUid, engineGid)

    #
    # This to allow current pretty output
    #
    if not foreground and os.fork() != 0:
        return

    engineConsoleLog = open(engineConsoleLogFile, "w+")

    class TerminateException(Exception):
        pass
    def myterm(signum, frame):
        raise TerminateException()

    with daemon.DaemonContext(
        detach_process=not foreground,
        signal_map={
            signal.SIGTERM: myterm,
            signal.SIGINT: myterm,
            signal.SIGHUP: None,
        },
        uid=engineUid,
        gid=engineGid,
        stdout=engineConsoleLog,
        stderr=engineConsoleLog,
    ):
        saveEnginePid(os.getpid())

        try:
            p = subprocess.Popen(
                args=engineArgs,
                executable=javaLauncher,
                env=engineEnv,
                close_fds=True,
            )
            p.wait()

            if p.returncode != 0:
                raise Exception("Engine terminated with status code %s" % p.returncode)

        except TerminateException:
            stopTime = engineConfig.getInteger("ENGINE_STOP_TIME")
            stopInterval = engineConfig.getInteger("ENGINE_STOP_INTERVAL")

            # avoid recursive signals
            for sig in (signal.SIGTERM, signal.SIGINT):
                signal.signal(sig, signal.SIG_IGN)

            try:
                p.terminate()
                for i in range(stopTime // stopInterval):
                    if p.poll() is not None:
                        break
                    time.sleep(stopInterval)
            except OSError as e:
                syslog.syslog(syslog.LOG_WARNING, "Cannot terminate pid %d: %s." % (p.pid, e))

            try:
                if p.poll() is None:
                    p.kill()
                    raise Exception("Had to kill engine process %s" % p.pid)
            except OSError as e:
                syslog.syslog(syslog.LOG_WARNING, "Cannot kill pid %d: %s." % (p.pid, e))
                raise

        finally:
            # Remove the PID file:
            removeEnginePid()

            # Clean the temporary directory:
            if os.path.exists(engineTmpDir):
                shutil.rmtree(engineTmpDir)


def linkModules(modulesDir, modulesTmpDir):
    # For each directory in the modules directory create the same in the
    # temporary directory and populate with symlinks pointing to the
    # original files (excluding indexes):
    for parentDir, childrenDirs, childrenFiles in os.walk(modulesDir):
        parentTmpDir = parentDir.replace(modulesDir, modulesTmpDir, 1)
        if not os.path.exists(parentTmpDir):
            os.makedirs(parentTmpDir)
        for childFile in childrenFiles:
            if childFile.endswith(".index"):
                continue
            childPath = os.path.join(parentDir, childFile)
            childTmpPath = os.path.join(parentTmpDir, childFile)
            os.symlink(childPath, childTmpPath)


def main():
    loadConfig()

    parser = OptionParser(
        usage="usage: %prog [options] start",
    )
    parser.add_option(
        "--pidfile",
        dest="pidfile",
        default=None,
        metavar="FILE",
        help="pid file to use",
    )
    parser.add_option(
        "--background",
        dest="background",
        action="store_true",
        default=False,
        help="Go into the background",
    )
    global options
    (options, args) = parser.parse_args()

    global engineConsoleLogFile
    global foreground

    if options.pidfile is not None:
        enginePidFile = options.pidfile
    foreground = not options.background

    if len(args) != 1:
        parser.error("action is missing")
    action = args[0]
    if not action in ("start"):
        parser.error("invalid action '%s'" % action)

    # Run the action with syslog open and remember to close it
    # regardless of what happens in the middle:
    syslog.openlog(engineName, syslog.LOG_PID)
    try:
        startEngine()
    except Exception as exception:
        syslog.syslog(syslog.LOG_ERR, str(exception))
        sys.exit(1)
    else:
        sys.exit(0)
    finally:
        syslog.closelog()


if __name__ == "__main__":
    main()
